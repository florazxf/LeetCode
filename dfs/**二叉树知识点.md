# 基本操作
1. 创建值为v的节点 `TreeNode* node = new TreeNode(v)`
2. 让S是T的左节点 `T->left=S;`  

# 二叉树的知识

1. 一个节点的**最大贡献值**，就是以该节点为根节点的子树中寻找以该节点为起点的一条路径，使得该路径上的节点值之和最大
2. 一个结点的**最大路径和**，就是该节点的值与该节点左右子节点的最大贡献值

例子：[124. 二叉树中的最大路径和](https://github.com/florazxf/LeetCode/blob/master/dfs/*124.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C.cpp)

# 用栈来维护从根节点到当前节点的所有节点
还原先序遍历的二叉树  
[1028. 从先序遍历还原二叉树](https://github.com/florazxf/LeetCode/blob/master/dfs/1028.%20%E4%BB%8E%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%E8%BF%98%E5%8E%9F%E4%BA%8C%E5%8F%89%E6%A0%91.cpp)
