# 基本操作
1. 创建值为v的节点 `TreeNode* node = new TreeNode(v)`
2. 让S是T的左节点 `T->left=S;`  
3. 二叉树遍历框架，典型的非线性递归遍历结构：  
```cpp
/* 基本的二叉树节点 */
class TreeNode {
    int val;
    TreeNode left, right;
}

void traverse(TreeNode root) {
    if(root==NULL){
        return ;
    }
    traverse(root.left)
    traverse(root.right)
}
```

# 题目的问法知道怎么写代码  

# 二叉树的知识
## 路径总和  
1. 因为要求的是路径总和，我们首先明确题目是求从【根节点】到【叶节点】的路径和吗
    ① 如果是的话我们就只用在遍历到叶节点时判断是否满足条件即可。  
    ② 如果是任意节点出发 任意节点结束     
   - 我们可以设一个全局变量，遍历的时候在dfs内部应该把当前的结点的结果和那个历史全局值进行比较，得到题目要求的最值。如：[124. 二叉树中的最大路径和](https://github.com/florazxf/LeetCode/blob/master/dfs/*124.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C.cpp)  
   - 双重dfs，以每个结点为根节点遍历一遍。  
   
2. **保存状态**：当要保存每一条路径的结果时，就要用到**回溯**像113题，要把刚刚加入的结点移除。  
[112.路径总和](https://github.com/florazxf/LeetCode/blob/master/dfs/112.%20%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C.cpp)
[113.路径总和 II](https://github.com/florazxf/LeetCode/blob/master/dfs/113.%20%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C%20II)  
[124. 二叉树中的最大路径和](https://github.com/florazxf/LeetCode/blob/master/dfs/*124.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C.cpp)  
[437. 路径总和 III](https://github.com/florazxf/LeetCode/blob/master/dfs/437.%20%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C%20III.cpp)


## 二叉搜索树

# 常用方法

## 用栈来维护从根节点到当前节点的所有节点
还原先序遍历的二叉树  
[1028. 从先序遍历还原二叉树](https://github.com/florazxf/LeetCode/blob/master/dfs/1028.%20%E4%BB%8E%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%E8%BF%98%E5%8E%9F%E4%BA%8C%E5%8F%89%E6%A0%91.cpp)
