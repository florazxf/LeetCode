# 基本操作
1. 创建值为v的节点 `TreeNode* node = new TreeNode(v)`
2. 让S是T的左节点 `T->left=S;`  
3. 二叉树遍历框架，典型的非线性递归遍历结构：  
```cpp
/* 基本的二叉树节点 */
class TreeNode {
    int val;
    TreeNode left, right;
}

void traverse(TreeNode root) {
    traverse(root.left)
    traverse(root.right)
}
```

# 题目的问法知道怎么写代码  
1. 题目说这个结点**不一定是从根节点开始**的，意味着什么呢？  
   我们应该设一个全局变量，遍历的时候在dfs内部应该把当前的结点的结果和那个历史全局值进行比较，得到题目要求的最值。  
   
# 二叉树的知识
## 路径和
1. 一个节点的**最大贡献值**，就是以该节点为根节点的子树中寻找以该节点为起点的一条路径，使得该路径上的节点值之和最大
2. 一个结点的**最大路径和**，就是该节点的值与该节点左右子节点的最大贡献值

例子：[124. 二叉树中的最大路径和](https://github.com/florazxf/LeetCode/blob/master/dfs/*124.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C.cpp)


## 二叉搜索树

# 常用方法

## 用栈来维护从根节点到当前节点的所有节点
还原先序遍历的二叉树  
[1028. 从先序遍历还原二叉树](https://github.com/florazxf/LeetCode/blob/master/dfs/1028.%20%E4%BB%8E%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%E8%BF%98%E5%8E%9F%E4%BA%8C%E5%8F%89%E6%A0%91.cpp)
