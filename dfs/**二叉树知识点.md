# 基本操作
1. 创建值为v的节点 `TreeNode* node = new TreeNode(v)`
2. 让S是T的左节点 `T->left=S;`  
3. 二叉树遍历框架，典型的非线性递归遍历结构：  
```cpp
/* 基本的二叉树节点 */
class TreeNode {
    int val;
    TreeNode left, right;
}

void traverse(TreeNode root) {
    if(root==NULL){
        return ;
    }
    traverse(root.left)
    traverse(root.right)
}
```

# 题目的问法知道怎么写代码  

# 二叉树的知识
## 路径（路径和，路径上相同的值之类的）
1. 我们首先明确题目是求从【根节点】到【叶节点】的路径和吗  
    ① 如果是的话我们就只用在遍历到叶节点时判断是否满足条件即可。    
    ② 如果是任意节点出发 任意节点结束  
   方法一：  
   就返回的结果需要分为两部分，一部分是返回给父节点的值，一部分是以当前结点为根节点的值，如：    [124. 二叉树中的最大路径和](https://github.com/florazxf/LeetCode/blob/master/dfs/*124.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C.cpp)
   [687.最长同值路径](https://github.com/florazxf/LeetCode/blob/master/dfs/687.%20%E6%9C%80%E9%95%BF%E5%90%8C%E5%80%BC%E8%B7%AF%E5%BE%84.cpp)
   - 以当前结点为根节点：我们可以设一个全局变量，遍历的时候在dfs内部应该把当前的结点的结果和那个历史全局值进行比较，得到题目要求的最值。 这个值就是左右子树的和，因为以自己为根节点，那就是左右子树都包含  
   - 返回给父节点的值：左右子树的最值，因为你给父节点的贡献只能是走一条路，走左边或走右边  

   方法二： 双重dfs，以每个结点为根节点遍历一遍。   
 
   
2. **保存状态**：当要保存每一条路径的结果时，就要用到**回溯**像113题，要把刚刚加入的结点移除。  
[112.路径总和](https://github.com/florazxf/LeetCode/blob/master/dfs/112.%20%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C.cpp)  
[113.路径总和 II](https://github.com/florazxf/LeetCode/blob/master/dfs/113.%20%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C%20II.cpp) 
[124. 二叉树中的最大路径和](https://github.com/florazxf/LeetCode/blob/master/dfs/*124.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C.cpp)   
[437. 路径总和 III](https://github.com/florazxf/LeetCode/blob/master/dfs/437.%20%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C%20III.cpp)  
[543. 二叉树的直径](https://github.com/florazxf/LeetCode/blob/master/dfs/543.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84.cpp)[687.最长同值路径](https://github.com/florazxf/LeetCode/blob/master/dfs/687.%20%E6%9C%80%E9%95%BF%E5%90%8C%E5%80%BC%E8%B7%AF%E5%BE%84.cpp)  

## 遍历顺序（前序、中序、后序）  
很多题目问的问题其实就是遍历方式的不同，我们只用搞清楚我们应该使用哪种遍历顺序，然后套相应的模版即可  
1. 前序遍历PreOrder  
var preorderTraversal = function(root) {
  const res = []
  function traversal (root) {
    if (root !== null) {
      res.push(root.val) // 访问根节点的值
      traversal(root.left) // 递归遍历左子树
      traversal(root.right) // 递归遍历右子树
    }
  }
  traversal(root)
  return res
}
2. 中序遍历 Inorder  
中序遍历是先遍历左节点，再根节点，再右节点  
/*
ar inorderTraversal = function(root) {
  const res = []
  function traversal (root) {
    if (root !== null) {
      traversal(root.left)
      res.push(root.val)
      traversal(root.right)
    }
  }
  traversal(root)
  return res
}
*/
如果先右节点，再根节点，再左结点 就是逆中序遍历  
/*
ar inorderTraversal = function(root) {
  const res = []
  function traversal (root) {
    if (root !== null) {
      traversal(root.right)
      res.push(root.val)
      traversal(root.left)
    }
  }
  traversal(root)
  return res
}
*/
[538. 把二叉搜索树转换为累加树](https://github.com/florazxf/LeetCode/blob/master/dfs/538%20%7C%201038.%20%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91.cpp)  
3. 后序遍历  
/*
var postorderTraversal = function(root) {
  const res = []
  function traversal (root) {
    if (root !== null) {
      traversal(root.left)
      traversal(root.right)
      res.push(root.val)
    }
  }
  traversal(root)
  return res
}

*/

## 二叉搜索树

# 常用方法

## 用栈来维护从根节点到当前节点的所有节点
还原先序遍历的二叉树  
[1028. 从先序遍历还原二叉树](https://github.com/florazxf/LeetCode/blob/master/dfs/1028.%20%E4%BB%8E%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%E8%BF%98%E5%8E%9F%E4%BA%8C%E5%8F%89%E6%A0%91.cpp)
