# 基本操作
1. 创建值为v的节点 `TreeNode* node = new TreeNode(v)`
2. 让S是T的左节点 `T->left=S;`  
3. 二叉树遍历框架，典型的非线性递归遍历结构：  
```cpp
/* 基本的二叉树节点 */
class TreeNode {
    int val;
    TreeNode left, right;
}

void traverse(TreeNode root) {
    if(root==NULL){
        return ;
    }
    traverse(root.left)
    traverse(root.right)
}
```

# 题目的问法知道怎么写代码  

# 二叉树的知识
## 路径（路径和，路径上相同的值之类的）
1. 我们首先明确题目是求从【根节点】到【叶节点】的路径和吗  
    ① 如果是的话我们就只用在遍历到叶节点时判断是否满足条件即可。    
    ② 如果是任意节点出发 任意节点结束  
   方法一：  
   就返回的结果需要分为两部分，一部分是返回给父节点的值，一部分是以当前结点为根节点的值  
   - 以当前结点为根节点：我们可以设一个全局变量，遍历的时候在dfs内部应该把当前的结点的结果和那个历史全局值进行比较，得到题目要求的最值。 这个值就是左右子树的和，因为以自己为根节点，那就是左右子树都包含  
   - 返回给父节点的值：左右子树的最值，因为你给父节点的贡献只能是走一条路，走左边或走右边
   另一种方法： 双重dfs，以每个结点为根节点遍历一遍。   
   如：    
   [124. 二叉树中的最大路径和](https://github.com/florazxf/LeetCode/blob/master/dfs/*124.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C.cpp)  
   [687.最长同值路径](https://github.com/florazxf/LeetCode/blob/master/dfs/687.%20%E6%9C%80%E9%95%BF%E5%90%8C%E5%80%BC%E8%B7%AF%E5%BE%84.cpp)  
   
2. **保存状态**：当要保存每一条路径的结果时，就要用到**回溯**像113题，要把刚刚加入的结点移除。  
[112.路径总和](https://github.com/florazxf/LeetCode/blob/master/dfs/112.%20%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C.cpp)
[113.路径总和 II](https://github.com/florazxf/LeetCode/blob/master/dfs/113.%20%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C%20II)  
[124. 二叉树中的最大路径和](https://github.com/florazxf/LeetCode/blob/master/dfs/*124.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C.cpp)  
[437. 路径总和 III](https://github.com/florazxf/LeetCode/blob/master/dfs/437.%20%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C%20III.cpp)
[687.最长同值路径](https://github.com/florazxf/LeetCode/blob/master/dfs/687.%20%E6%9C%80%E9%95%BF%E5%90%8C%E5%80%BC%E8%B7%AF%E5%BE%84.cpp)


## 二叉搜索树

# 常用方法

## 用栈来维护从根节点到当前节点的所有节点
还原先序遍历的二叉树  
[1028. 从先序遍历还原二叉树](https://github.com/florazxf/LeetCode/blob/master/dfs/1028.%20%E4%BB%8E%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%E8%BF%98%E5%8E%9F%E4%BA%8C%E5%8F%89%E6%A0%91.cpp)
